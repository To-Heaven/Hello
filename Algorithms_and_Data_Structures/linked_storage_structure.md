## 线性表的链式存储结构

#### 链式存储结构是什么鬼
- 链式存储结构用一组任意的存储单元存储线性表的数据元素，这组存储单元可以在内存中未被占用的任意位置，每一个数据元素除了存储其本身数据元素信息之外，还要存储指向其后继存储元素的信息。
	- 数据域：存储数据信息的域
	- 指针域：存储直接后继位置
	- 节点Node = 数据域 + 指针域

## 单链表
- 链表中的每一个节点中只包含一个指针域

#### 特点
- 第一个节点的存储位置是头指针，头指针head指向链表中第一个节点（头结点）
- 最后一个节点指针为NULL

#### 头指针与头节点
###### 头结点
- 数据域一般不存储数据。
- 头结点为了操作同一和方便而设立，放在第一个元素的节点之前，其数据与一般没有意义，不过也可以用来存放链表的长度
- 有了头结点，对在第一个元素节点（头结点后的第一个节点）前插入和删除节点的操作就与其他节点的操作及统一了
- 头结点不是链表的必要元素

```
头指针 --> 头结点 ---> a1(数据域) | p(指针域)

```

###### 头指针
- 指向链表第一个节点的指针，如果链表有头节点，则头指针就是指向头结点的指针
- **头指针具有标识作用，常用头指针指针变量的名字作为链表的名字**
- 无论链表是否为空，头指针均不为空，因为一旦头指针不存在，那么链表也就不存在了。
- 因此，头指针是链表的必要元素


#### 使用结构指针表述单链表

```c
# 节点由存放数据元素的数据域和存放后继节点位置的指针域组成 

typedef struct Node
{
	ElemType data;	# 数据域
	struct Node* Next;	# 指针域		
}Node;
typedef struct Node* LinkList;     	# 取别名
```

```
# 

int *i, j	# i是指针，j不是指针	

*int i, j	# i和j都是指针
```

###### 描述举例
- p 为一个指向线性表第i个元素ai的指针
	- p->data  : ai的数据域
	- p->next  : ai的指针域
		- p->next指针域中指针指向的是ai+1元素节点的位置
		- p->next->data指第ai+1元素节点的数据域


#### 单链表的读取
###### 特点
- 必须从第一个元素开始遍历查找

###### 注意
- 单链表中没有定义表长，因此要遍历单链表时候，我们不知道要循环多少次，所以不能使用for迭代来遍历单链表，应该使用while循环

###### 获取第i个元素算法思路
1. 声明一个指针p指向链表的第一个结点，初始化变量j从1开始
2. j<i的时候，遍历列表，让p的指针向后移动，不断只想下一个结点，并且j+1
3. 当遍历到链表末尾时，p为空，说明第i个元素不存在，否则就查找成功，返回节点p的数据

```c
Status GetElem(LinkList L; int i , ElemType *e)
{
	int j;
	LinkList p;
	
	p = L->Next;
	j = 1;
	
	while (p && j<i)
	{
		p = p->next;
		++j;
	}
	
	if (!p || j>1)
	{
		return ERROR;
	}
	
	*e = p->data;
	
	return OK;
}
```

- 查找操作时间复杂度
	- 单链表查找第i个元素的时间复杂度取决于第i个元素的位置，如果该元素刚好在第一个，那么时间复杂度为O(1)，如果刚好在最后一个，时间复杂度就是O(n)
	- 因此综合来看，但单链表的获取元素的时间复杂度为O(n)




###### "工作指针后移"


#### 单链表的插入
###### 假设
- 假设现在有两个节点p和p->next，对应的数据域分别为ai与ai+1。现在有一个新的节点s，如果要把节点s插入到p与p->next之间

###### 实现
- 只需要先将s->next指向ai+1所在的节点，再将p->next指向s节点即可

```
s->next = p->next
p->next = s
```

###### 算法思路---将单链表中第i个数据插入节点

1. 声明一个节点p指向链表头结点，初始化j从1开始
2. 当j<i的时候，遍历链表，让p指针向后移动，不断只想下一个节点，并且j自增1
3. 当到达链表末尾时，如果p仍然为空，则第i个元素不存在
4. 否则就是查找成功，在系统中生成一个空节点s
5. 将元素e赋值给s节点的数据域s->data

###### C实现
```c
Status ListInsert(LinkList *L, int i, ElemType e) 
{
	int j;
	LinkList p, s;
	
	p = *L;
	j = 1;
	
	while(p && j<i)
	{
		p = p->next;
		j++;
	}
	
	if (!p || j>i)
	{
		return ERROR;
	}
	
	a = (LinkList)malloc(sizeof(Node));
	s->data = e;
	
	s->next = p->next;
	p->next = s;
	
	return s;
}
```

#### 单链表的删除
###### 假设
- 假设现在有三个节点，p1、p2、p3，现在要删除节点p2

###### 实现
- 只需要将p1的指针指向p3节点就可以


```
p1->next = p1->next->next

// 或者

temp = p1->next
p1->next = temp->next
```

###### 算法思路
1. 声明一个节点p指向链表第一个节点，初始化j为1
2. 当j<i的时候，便利链表，同时让p的指针向后移动，不断只想下一个节点，j自增1
3. 如果遍历到打链表末尾p仍是空，说明第i个元素不存在。
4. 否则就表示查找成功，将于删除节点p->next赋值给一q
5. 执行删除语句p->next = q->next
6. 将q节点中的数据赋值给e，作为返回
7. 释放q节点


###### C实现

```c
Status ListInsert(LinkList *L, int i, ElemType e) 
{
	int j;
	LinkList p, s;
	
	p = *L;
	j = 1;
	
	while(p && j<i)
	{
		p = p->next;
		j++;
	}
	
	if (!p || j>i)
	{
		return ERROR;
	}
	
	q = p->next;
	p->next = q->next;	
	
	*e = q->next;
	free(q);
	
	return OK;
}

``` 

## 效率
#### 单链表的插入与删除操作
- 事件复杂度都是O(n)

#### 与线性表的顺序存储结构
###### 插入和删除单个元素时
- 顺序存储结构和单链表的事件复杂度都是O(n)

###### 插入和删除多个元素时
- 顺序存储结构每一次插入元素都系要移动O(n)
- 单链表只需要再第一次插入元素时找到第i个位置的指针，时间复杂度为O(n)，而再后续的数据插入时，事件复杂度就是O(1)

- 因此，**对于插入或删除数据越频繁的操作，单链表的效率优势越明显**