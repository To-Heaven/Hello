# 线性表

```
// 线性表的抽象数据类型定义

ADT 线性表
Data
	线性表的数据对象集合为{a1, a2, ...m an}，每个元素的联系那个均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
Operation
	InitList(*L): 初始化操作，建立一个空的线性表。
	ListEmpty(L): 判断线性表是否为空表，若线性表为空表，返回true，否则返回false
	ClearList(*L): 将线性表清空
	GetElem(L, i, *e): 将线性表L中的第i个位置元素值返回给e
	LocateElem(L, e): 在线性表中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则表示失败
	ListInsert(*L, i, e): 在线性表L中第i个位置插入新元素e
	ListDelete(*L, i, *e): 删除线性表L中第I个位置元素，并用e返回其值
	ListLength(L): 返回线性表L的元素个数
endADT
```

- 定义
	- 由0个或多个数据元素构成的有限序列
		- 有限的
		- 元素之间是有先后顺序的
		- 多元素线性表中，第一个元素无前驱元素，最后一个元素没有后继元素，中间的元素有且只有一个前驱元素和一个后继元素
		- 元素之间的关系是一对一的关系
		- 线性表中的每一个元素只会记住其直接前驱元素和直接后继元素
- 直接前驱元素
	- 线性表中，位于某个元素A前，并且紧挨着A的就是A元素的直接前驱元素
- 直接后继元素
	- 线性表中，位于某个元素A后，并且紧挨着A的就是A元素的直接后继元素

## 抽象数据类型
- 抽象
	- 取出事物具有的普遍性的本质
		- 抽出问题的特征，忽略非本质的细节
		- 思考问题的方式
- 数据类型
	- 由两部分构成
		- 一组性质相同的值的集合
		- 在此集合上的一些操作的总称
 
- 分类（按照取值的不同）
	- 原子类型
		- 不可再分解的数据类型
	- 结构类型
		- 可以再分解
		- 由其他数据组合而成
- 抽象数据类型ADT(abstract data type)
	- 两部分（就是把数据类型和相关操作捆绑在一起）
		- 一个数学模型
			- 取决于其逻辑特性
		- 定义在数学模型上的一组操作
			- 与计算机内部如何实现无关


- 抽象数据类型定义（描述格式（伪代码））

```
ADT		抽象数据类型名
Data
		数据元素之间的逻辑关系
Operation
		操作
EndADT

```


- C语言实现求多个线性表并集

```c
void unionL(List *la, List lb){
	int La_len, Lb_len, i;
	
	EleType e;						// 一个通用的数据类型
	La_len = ListLength(*La);
	Lb_len = ListLength(Lb);

	for (i=1; i<= Lb_len; i++){
		GetElem(Lb, i, e);
		if(!LocateElem(*La, e)){
			LiistInsert(La, ++La_len, e)
		}
	}
}

```

## 物理存储方式的本质
- 再内存中找个初始地址，通过占位的形式，把一定的内存空间给占用了，并把相同数据类型的数据元素一次放在这块内容空间中


## 地址计算方法
> 算法中，线性表起始的位置是从1开始的

- 相邻元素之间存储位置关系
	- `LOC(A[i+1]) = LOC(Ai) + c`
		- LOC: location 元素地址函数
		- A[..] 元素
		- c： 数据类型ElemType对应的每一个A元素占用的存储单元（可以理解为每一个元素A占用的存储宽度）
- 对于线性表中第i个元素的存储位置
	- `LOC(Ai) = LOC(A1) + (i - i)c`
	
- 因此存储时间性能为O(1)
	-  因为获取线性表中的任意一个元素的操作只需要计算一次就可以获得


- 利用地址计算方法实现GetElem(*L, i, e) 

```c
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0


typedef int Status;
Status GetElem(Sqllist *L, int i, ElemType *e){
	if (L.Length==0 || i<1 || i>L.Length){
		return ERROR;
	}
	*e = L.data[i-1];
	
	return OK;	
}
```

- 线性表插入值的c语言实现和**插入算法**
	- 插入算法思路
		1. 如果插入位置不合理，抛出异常
		2. 如果线性表长度大于等于数组长度，抛出异常或者动态增加数组容量
		3. 从最后一个元素开始向前遍历到第i个位置，分别将已遍历的元素都向后移动一个位置
		4. 将要插入的元素插入到位置i处
		5. 线性表长度加1
	- c语言实现

```c
#define ERROR 0;
#define OK 1;
#define FALSE 0；
#define TRUE 1; 


status ListInsert(SqlList *L, int i, ElemType *e){
	int k;

	if(L->Length == MAXSIZE){
		return ERROR;
	}
	if(i，1 || i>L->length+1){
		return ERROR;	
	}
	if(i<=L->length){
		for(k=L->length-1; k>=i-1; k--){
			L->data[k+1] = L->data[k];
		}
	}

	L->data[i-1] = e;
	l->length++;

	return OK;
}
```


## 线性表的顺序存储结构
- 指用一段地址连续的存储单元一次存储线性表的数据元素


```
#define MAXSIZE 20
typedef int ElemType;
typedef struct{
	ElemType data[MAXSIZE];
	int length;  			// 线性表当前长度
}SqlList;

```

- 特性

- 顺序存储结封装需要三个属性
	- 储存空间的起始位置.数组data的存储位置就是线性表空间存储空间的存储位置
	- 线性表的最大存储容量.数组的长度MaxSize
	- 线性表的当前长度：length



## 线性表的链式存储结构