# 数据链路层

#### 链路与数据链路
**区别？**

- 链路：从一个节点到**相邻节点**之间的一段物理线路，并且**这段物理线路中间没有任何交换节点**
- 数据链路
	- 要实现数据在链路上的传输，除了必须有一条物理线路之外，还必须要有**用于控制传输数据的通信协议**，把实现了这些协议的硬件（网络适配器）和软件加到物理线路（链路）上就实现了数据链路。
	- 也就是说，数据链路包含了链路，并且实现了通过协议控制数据！
	
#### 协议数据单元（传输单位）
**帧**
- 帧的结构
	- 网络层的的`IP数据包`交给数据链路层之后，就成为了数据链路层的数据部分

```
帧首部  帧数据部分(IP数据报，即分组)  帧尾部

# 首部和尾部的作用就是确定比特流中帧的界限
```

- 首部`SOH`与尾部`EOT`
	- 如果是`acsii`码的文本传输，`SOH`和`EOT`只是一个名称，他们分别使用二进制的`00000001`和`00000100`代表帧首部和尾部



- 数据链路层如何从物理层上交的比特流成识别出帧？如何识别出帧是不完整的帧？
	1. 通过帧首部和帧尾部这两个标识来从比特流中获取帧
	2. 当接收到的帧中缺少帧首部或者帧尾部的时候，说明接收到的帧是不完整的 

**注意**
1. 所有在互联网上传输的数据都以**分组**为传送单位
2. 每个数据链路层协议都规定了所能传送的帧的数据部分长度上限**MTU(maxinum transfer unit最大传送单元)**

**透明传输问题**
-描述：帧的`数据部分`某一个字节的二进制代码刚好和`SOH`或`EOT`对应的二进制代码相同，会导致出现`错误的帧边界`，接收端只能接收到部分的帧数据
-分析：出现这种错误的原因是**接收端将帧数据中与`SOH或EOT`相同的字符看做了帧首部后者帧尾部**
-因此解决的思路就有两种：
	1. 不允许帧数据中出现与`SOH`和`EOT`相同的字符
	2. 即使帧数据中出现了与`SOH`和`EOT`相同的字符，也告诉接收端它不是真正的帧首部或帧尾部
- 解决方案：`字节填充`，使用的就是上面第二种思路。
	- 在帧数据中出现相同`SOH或EOT`的前面插入一个`转义字符ESC`，这个转义字符的二进制是`00011011`(对应十进制27，十六进制1B)。当数据链路层接收到这个帧时，会忽略被转义的`SOH或EOT`，从而找到正确的帧尾部，在将解析出的`IP数据报`交给`网络层`之前，将转义字符从数据报中剔除

**传输差错**
- 什么是可靠传输？
	- 说白了，就是数据链路层向网络层发送什么数据，网络层就能接收到什么数据。

- 假设现在，发送方连续发送了三个帧"a", "b", "c"
	- 比特差错，本质上就是传输的二进制bit流中，0被换成了1或者1被换成了0
	- 帧丢失：接收端收到了是"a", "c"
	- 帧重复：接收端接收到的时"a", "b", "b", "c"
	- 帧失序：接收端接收到的帧出现了乱序，"c", "b", "a"
 

#### 点对点信道和点对点协议PPP 

**特点**
- 使用一对一的点对点通信方式
	- 因此点对点协议中不需要`发送方`和`接收方`mac地址

**流程**
  **假设现在只考虑包含了网络层和数据链路层**，结点A向结点B发送数据流程如下
1. 结点A将网络层的IP数据报交给下一层数据链路层
2. 数据链路层中，为该IP数据报封装上帧首部和帧尾部，并将该帧发送给结点B
3. 结点B接收到该帧之后，会检查该帧是否有差错：
	- 如果没有差错，就会从收到的帧中提取出IP数据报，并交给网络层
	- 如果有差错，就会丢弃这个帧

**帧结构**
- `F`即`flag`，规定为`0x7E`(二进制对应01111110，十进制为126)，标识帧的起始和结束
	- 连续两个标志字段`F`标识这是一个空帧，需要丢弃
- `A`规定为`0xFF`，`C`规定为`0X03`目前并没有给出定义，因此没有携带PPP帧的信息
- `协议部分`
	- 为`0x0021`时，`信息部分`就代表`IP数据报`
	- 为`0x8021`时，`信息部分`就代表网络层的控制数据
- `FCS`:`CRC`的帧检验序列`FCS`
	- mark，待补充，还没搞懂`循环冗余检验CRC`是啥意思。。。

```
F  A  C  协议  信息部分  FCS  F

# F A C 分别占用1字节
# 协议 2字节
# 信息部分最大1500字节
# FCS4字节

```

#### 广播信道与以太网协议

**以太网的MAC帧**

- 结构
	- 目的mac地址
	- 源mac地址
	- 帧类型，用来标识上一层使用的什么协议，从而方便把接收到的MAC帧数据交给上一层的这个协议
		- `0x0800`IP数据包
	- 最小长度64字节，最大长度1500字节，因此数据部分最短长度为16字节
		- 当数据字段的数据小于46字节，就会在数据字段后加整数字节的填充字段。
		- 那么问题来了，将数据交给网络层时，如何剔除数据中填充的整数字段？
			- 解决方案：上层使用IP协议的时候，其首部有一个`总长度`的字段，`64-总长度=填充数据长度`
	
```
目的地址  源地址  类型  数据  FCS

# 目的地址，源地址 占6字节
# 帧类型，占2字节
# FCS帧检验序列4字节
```

**MAC帧的类型**
1. 单播帧，一对一
2. 多播帧，一对多
3. 广播帧，发送局域网内的所有站点

**适配器（网卡）的作用**
- 过滤功能。
	- 当适配器收到一个`mac帧`的时候，就会先用硬件检查`mac帧`中的`目标mac地址`，如果和本机的`mac地址`相同，就会收下该帧，否则就会丢弃该帧

#### 以太网交换机（第二层交换机）
**先说说网桥**
- 网桥对接收到的`帧`根据内部的`目标mac地址`进行转发和过滤
- 流程
	1. 网桥接收到一个帧，并不会向所有的接口发送这个帧，而是首先会根据`地址表`中的映射关系，找到`目标mac`地址对应的接口。
	2. 如果找到了匹配的`mac`地址，就会将`帧`转发给该接口对应的`mac地址`所在主机
	3. 如果没匹配到该`mac地址`，就会丢弃这个`帧`


**特点**
- 交换机实际上就是一个多接口的网桥。特点如下
	1. 每一个接口都直接与一台主机或另一个以太网交换机相连。（当交换机上的一个端口链接成功时，交换机的CPU就会在交换机的CPU会生成一张包含了`mac地址`和`交换机端口`的映射表，即MAC表。当局域网中的一台主机向局域网内的其他主机发送数据包的时候，就会直接通过MAC表中的映射关系找到目标主机在交换机上的端口号，直接将数据送到该端口对应的主机上。）
	2.  具有并行性，可以同时链接多对接口,，多对主机能能使通信，但是**网桥只能串行完成分析和转发一个帧**，**项目通信的主机之间是相互独立的，无冲突的传输数据**

**自学习功能**
- 先假设现在局域网中有一台交换机，该交换机对外提供了4个接口`1, 2, 3, 4`，这四个接口分别连接了`a, b, c, d`四台计算机，初始时，交换机的`mac表（也称交换表）`是空的
	1. 现在，`a`向同一局域网中的`b`发送了一个`mac帧`，这个帧首先会交给`交换机`
	2. 交换机接收到这个帧之后，会先查找`mac表`，此时`mac表`是空的，所以找不到目标`b`的`mac地址`
	3. 然后交换机就会把这个帧中的`源mac地址`a和a所在的接口1添加到`mac表`中，**并向除了a以外的其他所有接口以"广播"的方式发送这个帧**
	4. `b， c， d`接收到这个帧之后，各自适配器（网卡）就会检测帧中的`目标mac地址`是否是自己的`mac地址`，如果是，就会收下这个帧。注意，这个时候，b的mac地址并不会被添加到`mac表中`
	5. 接着，`b`向`a`发送一个`mac帧`，这个帧同样会先交给交换机
	6. 交换机首先从`mac表`中查找有没有存在`帧`中`目标mac地址a`对应的端口，如果有该端口，就会将该帧转发给主机`a`，并**记录下主机`b`的`mac地址`和对应的`接口`**。如果没有找到对应的端口，就会广播该帧，重复上面的过程


















