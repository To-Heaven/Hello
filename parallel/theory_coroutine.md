# 协程coroutine
#### 协程是什么？
- 协程即在一个线程下，并发的执行多个任务，是单线程下的并发，又称微线程
- 协程在本质上还是**异步非阻塞的技术**


#### 协程、进程、线程
- 线程和进程时内核级别的。操作系统来控制进程、线程的调度，因此进程、线程在阻塞、占用CPU时间过长或其他原因时，会被迫交出CPU的执行权限。
- 协程是用户级别的，一旦遇到IO，就会由用户应用程序负责控制切换，避免大量的上下文切换，这样在操作系统看来，协程所在的线程时没有遇到阻塞的，就充分利用了CPU资源
- **多线程，多进程。无论多线程和多进程，IO的调度更多取决于系统，而协程的方式，调度来自用户**

>  client->recv() 等待接收数据时,底层库在执行recv时会保存任务的状态，比如代码行数，局部变量的值。然后就跳回到EventLoop中了。当数据到来时，它再把保存任务的状态取出来，又开始继续执行

## 协程的特点
- 协程的任务调度是由用户的程序完成的。
- 协程的开销比之线程还要小。这意味着协程的创建和来回切换的时间要比线程和进程小的多。
- 协程可以最大限度的使用CPU资源，实现并发效果
- 协程本质是在单线程下运行的，无法利用多核。但是我们可以创建多个进程，每个进程下开启多个线程，每个线程下开启多个协程
- 协程一旦阻塞，将会阻塞整个线程，意味着线程被挂起，处于阻塞态
- 协程内的任务是交替运行的（微线程），同一时间内只有一个任务在运行，因此不需要对数据加锁

## 注意
- **同一个线程下多个密集计算型任务之间单纯的切换没有意义，必须存在IO才能有意义**



## 协程与效率
> 时刻牢记，同一个线程下，多个计算密集型任务之间的来回切换没有任何意义，必须等到IO才有意义。

- 如何实现单个线程效率最大化
	- 前提： cpu可以在该线程下的多个任务之间快速来回切换，并将任务切换之前的状态保存下来
	- **关键**：一旦线程下的某个任务出现了阻塞，CPU在用户级别就会切换到线程下的其他任务。这样，将一个线程下的IO耗费时间压缩到最小，实现效率最大化
	
- **计算密集型任务**
	- **对于计算密集型任务来说，线程、协程都不适合，因为他们本质上都是在一个CPU上工作，无法利用多核资源，来回切换反而会耗费CPU资源**。

## 协程的实现



#### 使用yield
- yield关键字在生成器中可以保存函数运行到该yield位置时的状态，当生成器再次被next调用的时候，生成器函数将继续从该位置继续往下运行，直到遇到了下一个yield。
- send可以把一个函数的结果传递给另外一个函数，这样就可以实现单线程内程序之间的切换



#### 使用greenlet
#### 使用gevent
#### 使用asyncio