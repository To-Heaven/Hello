
# sys模块

[点击查看我整理的sys模块思维导图](https://github.com/ZiaWang/Hello/blob/master/picture/sys-2.png?raw=true)


## introduce
 
> interpreter		解释器   
> maintain			保持  

- this module provides access to some variables used or maintained by the interpreter  and to functions that interact strongly with the interpreter.（就是这个模块提供了可以和python解释器进行交互的变量和函数）


## variables
- sys.argv
	- list of a commad line arguments passed for a python script.
	- argv[0] is the python script name or a full pathname or not , depend on the operating system
	- if no script name was passed to the Python interpreter , argv[0] is the empty string
> 命令行参数的应用——给python 脚本建立访问权限


```python
# t.py

import sys
print(sys.argv)

if sys.argv[1] == 'ziawang' and sys.argv[2] == '123':
    print('获取文件执行权限')
else:
    print('获取访问权限失败')
    
---------------------------------------
# 命令行参数交互结果

D:\files>python3 t.py ziawang 123
['t.py', 'ziawang', '123']
获取文件执行权限

D:\files>python3 t.py ziawang 123456
['t.py', 'ziawang', '123456']
获取访问权限失败

D:\files>

```  



> 使用 python3  -h  （获取命令行操作符的介绍）
 
```
C:\Users\Zia Wang>python3 -h
usage: python3 [option] ... [-c cmd | -m mod | file | -] [arg] ...
Options and arguments (and corresponding environment variables):
-b     : issue warnings about str(bytes_instance), str(bytearray_instance)
         and comparing bytes/bytearray with str. (-bb: issue errors)
-B     : don't write .py[co] files on import; also PYTHONDONTWRITEBYTECODE=x
-c cmd : program passed in as string (terminates option list)
-d     : debug output from parser; also PYTHONDEBUG=x
-E     : ignore PYTHON* environment variables (such as PYTHONPATH)
-h     : print this help message and exit (also --help)
-i     : inspect interactively after running script; forces a prompt even
         if stdin does not appear to be a terminal; also PYTHONINSPECT=x
-I     : isolate Python from the user's environment (implies -E and -s)
-m mod : run library module as a script (terminates option list)
-O     : optimize generated bytecode slightly; also PYTHONOPTIMIZE=x
-OO    : remove doc-strings in addition to the -O optimizations
-q     : don't print version and copyright messages on interactive startup
-s     : don't add user site directory to sys.path; also PYTHONNOUSERSITE
-S     : don't imply 'import site' on initialization
-u     : unbuffered binary stdout and stderr, stdin always buffered;
         also PYTHONUNBUFFERED=x
         see man page for details on internal buffering relating to '-u'
-v     : verbose (trace import statements); also PYTHONVERBOSE=x
         can be supplied multiple times to increase verbosity
-V     : print the Python version number and exit (also --version)
         when given twice, print more information about the build
-W arg : warning control; arg is action:message:category:module:lineno
         also PYTHONWARNINGS=arg
-x     : skip first line of source, allowing use of non-Unix forms of #!cmd
-X opt : set implementation-specific option
file   : program read from script file
-      : program read from stdin (default; interactive mode if a tty)
arg ...: arguments passed to program in sys.argv[1:]
```


> option			选择  
> specify			指定  
> interactively		交互的  


- sys.exit(msg)
	- Exit from Python. This is implemented by raising the SystemExit exception
	- cleanup actions specified by finally clauses of try statements are honored
	- `sys.exit(msg)`会触发SystemExit来中断程序

```python
import sys


try:
    sys.exit(0)
except SystemExit as e:
    print('exception message :', e)

print('in first')


try:
    sys.exit(1)
except SystemExit as e:
    print('exception message : ', e)

print('in last')


# 运行结果-------------------------------------------------
exception message : 0
in first
exception message :  1
in last



```



- sys.maxsize
	- an intger giving the maxmum value a variable of type Py_ssize can take. it's usually 2\**31-1 on a 32-bit platform for 2\**63-1 on a 64-bit platform

- sys.path
	- **是一个全局列表**
	- return  a list of string that specifies the search path for the modules. initalized form the emvironment variable PYTHONPATH, plus an installation-dependent default（返回模块搜索路径，**当我们使用import导入模块的时候，解释器就会遍历该列表中的每一个路径，直到导入成功**）
	- the first item of this list , path[0] is the directory containing the script that used to invoke the python interpreter（path列表的第一个元素的值是执行python脚本的路径）


```python
>>> import sys
>>> sys.path
['', 'D:\\Python36\\Lib\\idlelib', 'D:\\Python36\\python36.zip', 'D:\\Python36\\DLLs', 'D:\\Python36\\lib', 'D:\\Python36', 'D:\\Python36\\lib\\site-packages']
>>> 

```


- sys.paltform 
	- this string contains a platform identifier that can be used to append platform-specific components to sys.path




- sys.modules
	- **是一个全局字典，包含了从解释器运行开始后被导入的所有模块，重复导入同一个模块实际上只会导入一次，其后的导入仅仅是对该字典做了一个查询操作**，当解释器启动时会将该字典加载到内存
	- a dictionary that maps module names to modules which have alreadly been laded.  
	- \_\_name\_\_
		- 在当前文件的时候，\_\_name\_\_变量的值为"\_\_main\_\_"
		- __在当前的文件中导入别的模块的时候，__name__变量指向的是该模块的模块名__
	- sys.modules[\_\_name\_\_]会返回当前所在模块对象，你可以通过句点符`.`来访问该模块中的任何全局变量
	
```python
import sys


def module_func():
    print('in modulefunc.......')


print(sys.modules[__name__])

getattr(sys.modules[__name__], 'module_func')()

--------------------------------------------------------------------------
# 结果
<module '__main__' from 'D:/files/python_practice/20170814-0820/0816/practice.py'>
in modulefunc.......

```

#### sys.stdout, sys.stdin, sys.stderr
###### 1. sys.stdout和print的关系
- 当我们使用`print('hello ziawang')`打印一个字符串到控制台的时候，实际上调用的`sys.stdout.write('hello ziawang'+'\n')`，它会将结果输出到控制台

###### 2. sys.stdin与input的关系
- 当我们使用`input('name:')`在控制台交互的时候，实际上有两个步骤
	1. `sys.stdout.write('name:'+'\n')`
	2. `sys.stdin.readline()[:-1]`
		- 后面进行字符串切分是去掉`stdout`写入的换行符（换行符只占一个字符长度）

###### 注意
- `sys.stdout`本质上也是一个引用，它默认指向的是控制台，我们可以将其重定向到一个具备`write()`方法的对象上（比如文件对象），这实际上就是将`sys.stdout`的引用从控制台指向其他对象

- 我们知道，在python中，**变量之间的相互赋值本质上就是引用的传递过程**，那么我们可以将一个文件的引用（句柄）赋值给`stdout`
	- 当我们把`stdout`指向了一个文件对象的时候，`print`调用`stdout`的`write`方法起始就是在调用文件的`write`方法，所以就可以将内容写入文件了

- **重定向stdout之前，一定要记得备份其引用，即先保存到另外一个变量身上**

```python
import sys


temp = sys.stdout       # 备份

sys.stdout = open('ziawang.txt', 'w')       # 重定向

print('这段文字将在文件ziawang.txt中显示')

sys.stdout = temp           # 恢复

print('这段文字将在控制台打印')
``` 
