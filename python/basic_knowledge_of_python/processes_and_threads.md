## 操作系统的两大功能
1. 为应用软件提供各种功能的抽象接口
	- 隐藏了丑陋复杂的各种硬件接口，为应用程序提供了良好的接口
2. 将多个应用程序对硬件资源的竞态访问变得有序化
	- 进程之间的管理和协调调度是由操作系统完成的

> __进程的调度，分配给哪一个CPU运行（多核），是操作系统说了算__

##  多道技术——针对单核，实现（伪）并发
- 空间上的复用
	- 内存中可以同时存在多个程序
		- Note：各个程序内存空间之间必须实现物理级别的隔离
- 时间上的复用
	- CPU可以非常快的在各个程序之间来回的切换
		- CPU切换的两种条件
			1. 当一个程序占用CPU时间过长的时候
			2. 当CPU遇到了IO阻塞的时候
				- 比如在主进程中，将子进程加载到内存的时候会产生IO延迟，此时CPU不会一直等待到子进程加载内存完毕，而是会去先执行其他进程

## 什么是进程
- 软件运行过程的一个抽象的概念（程序运行过程的抽象）
- 进程与程序
	- 进程是一个程序运行过程的抽象
	- 而程序就是一个文件中的一堆代码
		- 这个程序每运行一次就会创建一个新的进程

- 以下两种情况导致一个进程再逻辑上不能进行
	1. 进程挂起(进程自身原因)
		- 进程中存在IO阻塞，该进程占用的CPU就会让出给其他进程去执行，保证CPU一直在工作
	2. 操作系统层面(与进程无关)
		-  一个进程占用时间过多或者优先级等原因，造作系统会调用其他进程去使用CPU

- 进程的三种状态
	- 运行
	- 阻塞
	- 就绪



## 并发与并行
- 并行是针对多核CPU而言的，对于具有多个CPU的一台计算机来说，他可以同时并行运行多个进程
	- 该进程数 = CPU个数

- 并发再单核CPU和多核CPU上都会出现。因为即使是多核CPU，其数量也无法满足计算机中程序对进程数的需求
	- 并发就是依靠多道技术来实现伪并行效果

-  **实现并发的核心**
	- 硬件每中断一个进行着的进程，操作系统都要把该进程运行中的所有状态记录下来
	- 操作系统有一个进程表，每一个进程占用的进程表项都会被记录进去
		- 该表存放了进程状态的重要信息：程序计数器、堆栈指针、内存分配状况、所有打开文件的状态、帐号和调度信息，以及其他在进程由运行态转为就绪态或阻塞态时，必须保存的信息，从而保证该进程在再次启动时，就像从未被中断过一样。

## 创建子进程
- 创建子进程的四种形式
	- 系统初始化
	- 一个进程在运行中创建子进程
	- 用户与操作系统之间的交互式请求（打开软件）
	- 一个批处理作业的初始化

- 所有创建新进程的方式都是基于操作系统中创建新进程的系统调用而创建的。
	1. Linux中，通过系统调用fork来创建子进程。创建的子进程在初始化的时候会复制父进程的内存空间，两者有相同的存储映像、同样打开的文件。
		- 在shell中，每执行一个命令就会创建一个子进程
	2. Windows中系统调用是CreateProcess，负责把正确的程序装入新进程

- 但是在不同的操作系统中，关于内存的分配是不一样的
	- 相同点：
		- 创建完进程之后，父进程和子进程有各自不同的地址空间（多道技术要求在物理层面实现进程之间内存的隔离），任何一个进程再其地址空间中的修改都不会影响到另一个进程
	- 不同点：
		- 在Linux系统中，子进程继承自父进程，会完全拷贝父进程初始状态的内存空间，两者可以有一个只读的共享内存区
		- 在Windows系统中，父进程和子进程的内存空间在一开始就是不同的
		
 
> 注意：进程是一种抽象的过程

- 要先向操作系统发起请求，然后再在内存中创建对应空间，然后子进程才能运行，这需要一段时间，CPU不会等这段时间


## 进程终止和僵尸进程
- 进程终止
	- 正常退出：用户关闭交互式界面，或程序正常运行结束后的正常退出。
		- Linux中exit，Windows中exitprocess
	- 出错退出：目标文件不存在
		- python3  a.py      a.py 不存在
	- 严重错误退出:错误语法，非法指令
	- 被其他进程杀死
		- kill -9 

- 僵尸进程
	-  子进程结束后父进程会清理器内存，如果父进程在子进程结束之前就已经终止了，那么这个子进程就变成了一个僵尸进程


## 查看进程id
- windows
	- `taskid`
	- `taskid  |  finestr python`    筛选含有python的进程



