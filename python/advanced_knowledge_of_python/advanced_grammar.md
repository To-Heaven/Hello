## 充分利用惰性运算（效率）
- 惰性运算
	- 所谓惰性运算，即仅仅在真正需要执行一段代码的时候才执行该代码，最小化计算机要做的工作
- 惰性运算的好处
	- 提高效率，避免没必要的运算
	- 可以构造一个无限长度的数据结构，节省空间

- 逻辑运算中的惰性运算
	- `if True or False`
		- 只要or左边为True，就直接返回结果，不再计算or后面的表达式的结果
	- `if False and True`
		- 只要and左边是False，就直接返回结果，不再计算and后面的表达式的结果
	- 综上
		- 对于and运算，应将False可能性高的判断内容放在and左边
		- 对于or运算，应将True可能性高的判断内容放在or的左边 
- 生成器
	- [获取生成器与迭代器知识](http://www.ziawang.com/python/basic_knowledge_of_python/iterator_generator.html)

## ++i  与  --i
- python中是支持`++i` 和 `--i` 运算的，但是仅仅是对符号的判断运算
	- 比如`--2`和`++2`两者得到`2`
	- 但是`2++`  `2--` 肯定会报错


## 连接字符串使用join而不是 + 
- 用`+`连接字符串
	- 每一次通过`+`连接两个字符串都会返回一个新的字符串对象，这就意味着在内存空间中就必须创建内存空间用于存放该对象，虽然python有垃圾处理机制，但是当用`+`连接大量的字符串时，每一次两个字符串的拼接都会申请和复制一次内存，频繁的在内存中开辟内存空间以及字符串对象的存取必然会对性能产生非常大的影响。
	
- 用`s.join(iterable)`连接字符串
	-  使用字符串的`join`方法拼接字符串的时候，解释器会首先计算并申请拼接整个字符串所需要的内存空间，然后将字符序列中的每一个元素复制到内存中去，整个过程只创建一次内存空间，大大提高了效率
	-  **join方法作用的对象必须是字符串序列**


## 生成式中要注意的地方
- 字典生成式的坑

```python
list_map = [(key, value) for key in 'abcdefg' for value in range(7)]
dict_iter = dict(list_map)
print(dict_iter)
# ------------------------------------------------------
{'a': 6, 'b': 6, 'c': 6, 'd': 6, 'e': 6, 'f': 6, 'g': 6}

# ------------------------------------------------------
dict_exp = {key:value for key in 'abcde' for value in range(10)}

print(dict_exp)
# --------------------------------------------------------
{'a': 9, 'b': 9, 'c': 9, 'd': 9, 'e': 9}
```