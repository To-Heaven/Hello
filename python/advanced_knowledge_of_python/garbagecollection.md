# python的垃圾回收机制


#### 概述
- python中垃圾回收的策略是**以引用计数为主，标记清除和分代收集为辅的策略**


#### 引用计数策略及其缺点
引用计数原理
- 当我们在内存中创建一个对象A的时候，这个对象A就会维护一个`引用计数`，这里暂且称之为counter，这个counter用来记录这个对象被引用的次数。
	1. 当有一个新的引用指向了这个对象的时候，引用计数counter的值就会增加1，比如我们创建了一个新的变量B，并执行`B=A`
	2. 当指向该对象的一个引用失效的时候，counter的值就会减1，比如`del B`
	3. 当counter的值为0的时候，这个对象就会被python解释器的垃圾回收线程回收。
	 
引用计数缺点
1. **维护引用计数需要额外的空间**
2. **无法解决对象之间的循环引用**，所谓循环引用，其实就是两个变量之间进行互相引用。
	- 要注意的是，python中对于字符串和数字等这些数值型是不会出现循环引用的，只有容器类型的数据比如字典，列表等才会出现`循环引用`的情况

循环引用举例
- 下面例子中，a里面包含了对b引用的元素，而b里面也包含了对a引用的元素，两者实现了循环引用，这个时候，在不存在`标记清除`和`分代收集`的情况下，即使我们使用`del a`和`del b`删除了变量a和变量b，变量a和变量b指向的对象的引用计数不会是0，而是为1，这意味着**引用计数机制不会回收这两个对象，这两个对象就会一直存在于内存中，造成内存泄露**。

```python
a = []
b = []
a.append(b)
b.append(a)
```

为了解决引用计数循环调用的问题，python中还使用了`标记清除`和`分代收集`策略

#### 标记清除
标记清除算法有两个阶段
1. 标记阶段。标记阶段会将所有处于`活动状态`的对象绑定一个`标记`
2. 回收阶段。这个阶段会将所有没有绑定`标记`的`非活动对象`回收。

标记清除算法如何区分`活动对象`和`非活动对象`？
[参考:http://www.memorymanagement.org/mmref/recycle.html#tracing-collectors](http://www.memorymanagement.org/mmref/recycle.html#tracing-collectors)
![标记清除突变](http://www.memorymanagement.org/_images/mark-sweep.svg)

1. 首先，相互引用的对象之间通过引用链接在一起，构成一张`有向图`，每一个对象就是这个有向图的节点，每一个对象对另一个对象的引用使用带有箭头的线段表示
2. 从根对象触发，沿着有方向的边遍历`有向图`中的节点对象，根据箭头可以通过遍历到达的对象就是`活动对象`，而无法到达的对象就是`非活动对象`
	- 上图中`1, 2, 3`是活动对象，`4， 5`是非活动对象

标记清除算法的缺点
1. 清除非活动对象之前，为了区分出哪些是非活动对象，他需要遍历整个堆内存。


#### 分代收集（以空间换时间的操作方式）
python根据内存中对象存活时间的长短将内存中的对象划分到了三个`代`中（0， 1， 2），每一个`代`都对应一个链表，每一个`代`中对对象的垃圾回收频率随着对象存活时间的增大而减少，因此对于`第0代`来说，其垃圾回收的频率最快，对于`第2代`来说，其垃圾回收的频率最低。流程如下
1. 每当我们新创建一个对象，该对象对会被分配在年轻代（即第0代）
2. 当年轻代链表中节点的总数达到最大的时候，就会触发python的垃圾回收机制，**基于标记清除将年轻代中的`非活动状态`的对象回收，剩下的`活动状态`的对象就会被存放到`中年代(第1代)`中**
3. 当`中年代`中的链表达到了最大长度的时候，也会触发python的垃圾回收机制，然后执行和上面相同的操作，将处于`活动态`的对象移动到`老年代(第2代)`中。
4. `老年代`中的对象是是存活时间最久的对象。














